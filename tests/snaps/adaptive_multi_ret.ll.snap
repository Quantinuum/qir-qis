---
source: src/convert.rs
expression: qis_text.unwrap().to_string()
---
; ModuleID = 'qis_module'
source_filename = "tests/data/adaptive_multi_ret.ll"
target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"
target triple = "aarch64-unknown-linux-gnu"

%Qubit = type opaque

@qis_qs = private unnamed_addr global [1 x i64] zeroinitializer
@e_qalloc_fail = private constant [47 x i8] c".EXIT:INT:No more qubits available to allocate."
@res_0 = private constant [14 x i8] c"\0DUSER:RESULT:0"
@gen_name = local_unnamed_addr global [7 x i8] c"qir-qis", section ",generator"
@gen_version = local_unnamed_addr global [5 x i8] c"0.0.0", section ",generator"

define i64 @___user_qir_main() local_unnamed_addr {
entry:
  %qalloc.i = tail call i64 @___qalloc()
  %is_fail.i = icmp eq i64 %qalloc.i, -1
  br i1 %is_fail.i, label %qalloc_fail.i, label %qir_qis.init_qubit.exit

qalloc_fail.i:                                    ; preds = %entry
  tail call void @panic(i32 1001, i8* getelementptr inbounds ([47 x i8], [47 x i8]* @e_qalloc_fail, i64 0, i64 0))
  unreachable

qir_qis.init_qubit.exit:                          ; preds = %entry
  tail call void @___reset(i64 %qalloc.i)
  store i64 %qalloc.i, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @qis_qs, i64 0, i64 0), align 8
  tail call void @___rxy(i64 %qalloc.i, double 0x3FF921FB54442D18, double 0xBFF921FB54442D18)
  %qbit.i5 = load i64, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @qis_qs, i64 0, i64 0), align 8
  tail call void @___rz(i64 %qbit.i5, double 0x400921FB54442D18)
  %qbit2 = load i64, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @qis_qs, i64 0, i64 0), align 8
  %meas = tail call i64 @___lazy_measure(i64 %qbit2)
  %bool = tail call i1 @___read_future_bool(i64 %meas)
  tail call void @___dec_future_refcount(i64 %meas)
  br i1 %bool, label %common.ret, label %exit

common.ret:                                       ; preds = %exit, %qir_qis.init_qubit.exit
  %common.ret.op = phi i64 [ 0, %exit ], [ 1, %qir_qis.init_qubit.exit ]
  %qbit4 = load i64, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @qis_qs, i64 0, i64 0), align 8
  tail call void @___qfree(i64 %qbit4)
  ret i64 %common.ret.op

exit:                                             ; preds = %qir_qis.init_qubit.exit
  tail call void @print_bool(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @res_0, i64 0, i64 0), i64 13, i1 false)
  br label %common.ret
}

declare i64 @___qalloc() local_unnamed_addr

declare void @panic(i32, i8*) local_unnamed_addr

declare void @___reset(i64) local_unnamed_addr

; Function Attrs: mustprogress nofree norecurse nosync nounwind readonly willreturn
define i64 @qir_qis.load_qubit(%Qubit* %0) local_unnamed_addr #0 {
entry:
  %idx = ptrtoint %Qubit* %0 to i64
  %qbit_ptr = getelementptr [1 x i64], [1 x i64]* @qis_qs, i64 0, i64 %idx
  %qbit = load i64, i64* %qbit_ptr, align 8
  ret i64 %qbit
}

declare void @___rxy(i64, double, double) local_unnamed_addr

declare void @___rz(i64, double) local_unnamed_addr

declare i64 @___lazy_measure(i64) local_unnamed_addr

declare i1 @___read_future_bool(i64) local_unnamed_addr

declare void @___dec_future_refcount(i64) local_unnamed_addr

declare void @print_bool(i8*, i64, i1) local_unnamed_addr

declare void @___qfree(i64) local_unnamed_addr

define i64 @qmain(i64 %0) local_unnamed_addr {
entry:
  tail call void @setup(i64 %0)
  %1 = tail call i64 @___user_qir_main()
  %retval = tail call i64 @teardown()
  ret i64 %retval
}

declare void @setup(i64) local_unnamed_addr

declare i64 @teardown() local_unnamed_addr

attributes #0 = { mustprogress nofree norecurse nosync nounwind readonly willreturn }

!llvm.module.flags = !{!0, !1, !2, !3}
!name = !{!4}

!0 = !{i32 1, !"qir_major_version", i32 1}
!1 = !{i32 7, !"qir_minor_version", i32 0}
!2 = !{i32 1, !"dynamic_qubit_management", i1 false}
!3 = !{i32 1, !"dynamic_result_management", i1 false}
!4 = !{!"mainlib"}
